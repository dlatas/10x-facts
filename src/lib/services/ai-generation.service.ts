import type { Topic } from '@/types';
import type { SupabaseClient } from '@/db/supabase.client';

export interface DailyLimit {
  remaining: number;
  resetAtUtc: string;
}

export type AiEventStatus = 'accepted' | 'rejected' | 'skipped' | 'failed';

interface OpenRouterChatCompletionResponse {
  id?: string;
  model?: string;
  choices?: {
    message?: { content?: string | null };
  }[];
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
}

export function toUtcDayString(dateUtc: Date): string {
  // YYYY-MM-DD in UTC
  return dateUtc.toISOString().slice(0, 10);
}

function nextUtcMidnightIso(nowUtc: Date): string {
  const d = new Date(
    Date.UTC(
      nowUtc.getUTCFullYear(),
      nowUtc.getUTCMonth(),
      nowUtc.getUTCDate() + 1,
      0,
      0,
      0,
      0
    )
  );
  return d.toISOString();
}

export async function computeDailyLimit(args: {
  supabase: SupabaseClient;
  userId: string;
  nowUtc?: Date;
  dailyEventLimit: number;
}): Promise<DailyLimit> {
  const nowUtc = args.nowUtc ?? new Date();
  const dayUtc = toUtcDayString(nowUtc);

  const { count, error } = await args.supabase
    .from('ai_generation_events')
    .select('id', { head: true, count: 'exact' })
    .eq('user_id', args.userId)
    .eq('day_utc', dayUtc)
    .in('status', ['accepted', 'rejected', 'skipped']);

  if (error) throw error;

  const used = count ?? 0;
  const remaining = Math.max(0, args.dailyEventLimit - used);

  return { remaining, resetAtUtc: nextUtcMidnightIso(nowUtc) };
}

export function getIsRandomTopic(topic: Pick<Topic, 'system_key'>): boolean {
  return topic.system_key === 'random_topic';
}

export async function createAutoGeneratedFlashcard(args: {
  supabase: SupabaseClient;
  userId: string;
  topicId: string;
  front: string;
  back: string;
}): Promise<{ id: string }> {
  const { data, error } = await args.supabase
    .from('flashcards')
    .insert({
      user_id: args.userId,
      topic_id: args.topicId,
      front: args.front,
      back: args.back,
      source: 'auto_generated',
      is_favorite: false,
      edited_by_user: false,
    })
    .select('id')
    .single();

  if (error) throw error;
  if (!data?.id) throw new Error('Nie udało się utworzyć fiszki.');
  return { id: data.id };
}

export async function insertAiGenerationEvent(args: {
  supabase: SupabaseClient;
  userId: string;
  topicId: string;
  status: AiEventStatus;
  isRandom: boolean;
  randomDomainLabel: string | null;
  model?: string | null;
  promptTokens?: number | null;
  completionTokens?: number | null;
  latencyMs?: number | null;
}): Promise<{ id: string }> {
  const { data, error } = await args.supabase
    .from('ai_generation_events')
    .insert({
      user_id: args.userId,
      topic_id: args.topicId,
      status: args.status,
      is_random: args.isRandom,
      random_domain_label: args.randomDomainLabel,
      model: args.model ?? null,
      prompt_tokens: args.promptTokens ?? null,
      completion_tokens: args.completionTokens ?? null,
      latency_ms: args.latencyMs ?? null,
    })
    .select('id')
    .single();

  if (error) throw error;
  if (!data?.id) throw new Error('Nie udało się zapisać eventu AI.');
  return { id: data.id };
}

function clampText(v: string, maxLen: number): string {
  const trimmed = v.trim();
  if (trimmed.length <= maxLen) return trimmed;
  return trimmed.slice(0, maxLen).trim();
}

function extractJsonObject(text: string): unknown {
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start === -1 || end === -1 || end <= start) return null;
  try {
    return JSON.parse(text.slice(start, end + 1));
  } catch {
    return null;
  }
}

export async function generateProposalViaOpenRouter(args: {
  apiKey: string;
  model: string;
  topic: Pick<Topic, 'name' | 'description'>;
  timeoutMs?: number;
}): Promise<{
  front: string;
  back: string;
  model: string;
  promptTokens?: number;
  completionTokens?: number;
  latencyMs: number;
}> {
  const controller = new AbortController();
  const timeoutMs = args.timeoutMs ?? 20_000;
  const t0 = Date.now();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);

  const systemPrompt = [
    'Jesteś asystentem do tworzenia fiszek (front/back) do nauki.',
    'Zwróć WYŁĄCZNIE poprawny JSON w formacie: {"front":"...","back":"..."}.',
    'front: krótki tytuł/pytanie (max 200 znaków).',
    'back: zwięzłe wyjaśnienie (max 600 znaków).',
    'Nie dodawaj dodatkowych pól ani tekstu poza JSON.',
  ].join('\n');

  const userPrompt = [
    `Temat: ${args.topic.name}`,
    `Opis: ${args.topic.description}`,
    '',
    'Wygeneruj dokładnie jedną fiszkę w wymaganym formacie JSON.',
  ].join('\n');

  try {
    const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${args.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: args.model,
        temperature: 0.6,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
      }),
      signal: controller.signal,
    });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      const err = new Error(
        `OpenRouter error: ${res.status} ${res.statusText}${text ? `; body=${text}` : ''}`
      );
      // @ts-expect-error attach http status for mapping
      err.httpStatus = res.status;
      throw err;
    }

    const json = (await res.json()) as OpenRouterChatCompletionResponse;
    const content = json.choices?.[0]?.message?.content ?? '';

    const parsed = extractJsonObject(content);
    const obj =
      typeof parsed === 'object' && parsed !== null
        ? (parsed as Record<string, unknown>)
        : null;

    const rawFront = typeof obj?.front === 'string' ? obj.front : '';
    const rawBack = typeof obj?.back === 'string' ? obj.back : '';

    const front = clampText(rawFront, 200);
    const back = clampText(rawBack, 600);

    if (!front || !back) {
      throw new Error(
        'Nie udało się sparsować odpowiedzi AI do formatu {front, back}.'
      );
    }

    return {
      front,
      back,
      model: json.model ?? args.model,
      promptTokens: json.usage?.prompt_tokens,
      completionTokens: json.usage?.completion_tokens,
      latencyMs: Date.now() - t0,
    };
  } finally {
    clearTimeout(timeout);
  }
}
