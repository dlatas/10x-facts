import type { Topic } from '@/types';
import type { SupabaseClient } from '@/db/supabase.client';

export interface DailyLimit {
  remaining: number;
  resetAtUtc: string;
}

export type AiEventStatus = 'accepted' | 'rejected' | 'skipped' | 'failed';

interface OpenRouterChatCompletionResponse {
  id?: string;
  model?: string;
  choices?: {
    message?: { content?: string | null };
  }[];
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
}

export function toUtcDayString(dateUtc: Date): string {
  // YYYY-MM-DD in UTC
  return dateUtc.toISOString().slice(0, 10);
}

function nextUtcMidnightIso(nowUtc: Date): string {
  const d = new Date(
    Date.UTC(
      nowUtc.getUTCFullYear(),
      nowUtc.getUTCMonth(),
      nowUtc.getUTCDate() + 1,
      0,
      0,
      0,
      0
    )
  );
  return d.toISOString();
}

export async function computeDailyLimit(args: {
  supabase: SupabaseClient;
  userId: string;
  nowUtc?: Date;
  dailyEventLimit: number;
}): Promise<DailyLimit> {
  const nowUtc = args.nowUtc ?? new Date();
  const dayUtc = toUtcDayString(nowUtc);

  const { count, error } = await args.supabase
    .from('ai_generation_events')
    .select('id', { head: true, count: 'exact' })
    .eq('user_id', args.userId)
    .eq('day_utc', dayUtc)
    .in('status', ['accepted', 'rejected', 'skipped']);

  if (error) throw error;

  const used = count ?? 0;
  const remaining = Math.max(0, args.dailyEventLimit - used);

  return { remaining, resetAtUtc: nextUtcMidnightIso(nowUtc) };
}

export function getIsRandomTopic(topic: Pick<Topic, 'system_key'>): boolean {
  return topic.system_key === 'random_topic';
}

export interface RandomTopicDomain {
  /**
   * Telemetry label: a-z0-9_- (max 64)
   */
  label: string;
  /**
   * Human-friendly title used in the prompt.
   */
  title: string;
  /**
   * Description used in the prompt.
   */
  description: string;
}

export const RANDOM_TOPIC_DOMAINS: readonly RandomTopicDomain[] = [
  {
    label: 'historia',
    title: 'Historia',
    description:
      'Ciekawostki historyczne: daty, wydarzenia, postacie, ważne zależności przyczynowo-skutkowe.',
  },
  {
    label: 'technologia',
    title: 'Technologia',
    description:
      'Ciekawostki ze świata technologii: IT, internet, bezpieczeństwo, trendy i przełomowe wynalazki.',
  },
  {
    label: 'nauka',
    title: 'Nauka',
    description:
      'Ciekawostki naukowe: fizyka, biologia, chemia, astronomia; zwięzłe i konkretne wyjaśnienia.',
  },
  {
    label: 'geografia',
    title: 'Geografia',
    description:
      'Ciekawostki geograficzne: państwa, stolice, miejsca, zjawiska naturalne oraz rekordy świata.',
  },
  {
    label: 'kultura',
    title: 'Kultura',
    description:
      'Ciekawostki z kultury: sztuka, muzyka, literatura, kino; krótkie i konkretne fakty.',
  },
] as const;

export function pickRandomTopicDomain(): RandomTopicDomain {
  const list = RANDOM_TOPIC_DOMAINS;
  if (!list.length) {
    return { label: 'random', title: 'Losowy', description: '' };
  }
  const idx = Math.floor(Math.random() * list.length);
  return list[idx] ?? list[0]!;
}

export async function createAutoGeneratedFlashcard(args: {
  supabase: SupabaseClient;
  userId: string;
  topicId: string;
  front: string;
  back: string;
}): Promise<{ id: string }> {
  const { data, error } = await args.supabase
    .from('flashcards')
    .insert({
      user_id: args.userId,
      topic_id: args.topicId,
      front: args.front,
      back: args.back,
      source: 'auto_generated',
      is_favorite: false,
      edited_by_user: false,
    })
    .select('id')
    .single();

  if (error) throw error;
  if (!data?.id) throw new Error('Nie udało się utworzyć fiszki.');
  return { id: data.id };
}

export async function insertAiGenerationEvent(args: {
  supabase: SupabaseClient;
  userId: string;
  topicId: string;
  status: AiEventStatus;
  isRandom: boolean;
  randomDomainLabel: string | null;
  model?: string | null;
  promptTokens?: number | null;
  completionTokens?: number | null;
  latencyMs?: number | null;
}): Promise<{ id: string }> {
  const { data, error } = await args.supabase
    .from('ai_generation_events')
    .insert({
      user_id: args.userId,
      topic_id: args.topicId,
      status: args.status,
      is_random: args.isRandom,
      random_domain_label: args.randomDomainLabel,
      model: args.model ?? null,
      prompt_tokens: args.promptTokens ?? null,
      completion_tokens: args.completionTokens ?? null,
      latency_ms: args.latencyMs ?? null,
    })
    .select('id')
    .single();

  if (error) throw error;
  if (!data?.id) throw new Error('Nie udało się zapisać eventu AI.');
  return { id: data.id };
}

function clampText(v: string, maxLen: number): string {
  const trimmed = v.trim();
  if (trimmed.length <= maxLen) return trimmed;
  return trimmed.slice(0, maxLen).trim();
}

function extractJsonObject(text: string): unknown {
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start === -1 || end === -1 || end <= start) return null;
  try {
    return JSON.parse(text.slice(start, end + 1));
  } catch {
    return null;
  }
}

export async function generateProposalViaOpenRouter(args: {
  apiKey: string;
  model: string;
  topic: Pick<Topic, 'name' | 'description'>;
  avoidFronts?: string[];
  timeoutMs?: number;
}): Promise<{
  front: string;
  back: string;
  model: string;
  promptTokens?: number;
  completionTokens?: number;
  latencyMs: number;
}> {
  const controller = new AbortController();
  const timeoutMs = args.timeoutMs ?? 20_000;
  const t0 = Date.now();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);

  // Small, safe variability to reduce repetitive generations for the same topic.
  // Never include this value in the returned JSON (enforced by system prompt).
  const variationSeed =
    (
      globalThis.crypto as { randomUUID?: () => string } | undefined
    )?.randomUUID?.() ?? `${Date.now()}-${Math.random().toString(16).slice(2)}`;

  const systemPrompt = [
    'Jesteś asystentem do tworzenia fiszek (front/back) do nauki.',
    'Zwróć WYŁĄCZNIE poprawny JSON w formacie: {"front":"...","back":"..."}.',
    'front: krótki tytuł/pytanie (max 200 znaków).',
    'back: zwięzłe wyjaśnienie (max 600 znaków).',
    'Nie dodawaj dodatkowych pól ani tekstu poza JSON.',
    'Za każdym wywołaniem wybierz INNY aspekt/podtemat (unikaj najoczywistszej definicji).',
    'Nie cytuj ani nie wypisuj żadnych identyfikatorów/seedów z treści zadania.',
  ].join('\n');

  const userPrompt = [
    `Temat: ${args.topic.name}`,
    `Opis: ${args.topic.description}`,
    '',
    ...(Array.isArray(args.avoidFronts) && args.avoidFronts.length > 0
      ? [
          'Nie powtarzaj poniższych tematów/pytań (front). Wybierz inny aspekt niż te przykłady:',
          ...args.avoidFronts
            .slice(0, 8)
            .map((f) => `- ${clampText(String(f ?? ''), 120)}`),
          '',
        ]
      : []),
    'Wybierz losowo jeden aspekt i skup się na nim (np. definicja, cel, zastosowanie, parametry/liczby, typowe błędy, praktyczne wskazówki, porównanie).',
    `Seed (nie wypisuj go w odpowiedzi): ${variationSeed}`,
    '',
    'Wygeneruj dokładnie jedną fiszkę w wymaganym formacie JSON.',
  ].join('\n');

  try {
    const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${args.apiKey}`,
        'Content-Type': 'application/json',
        // Avoid any intermediary caching of POST responses.
        'Cache-Control': 'no-store',
        Pragma: 'no-cache',
        // Best-effort cache buster for gateways/proxies.
        'X-Request-Id': variationSeed,
      },
      body: JSON.stringify({
        model: args.model,
        temperature: 0.9,
        top_p: 0.95,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
      }),
      // In runtimes that implement fetch caching, force no-store.
      cache: 'no-store',
      signal: controller.signal,
    });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      const err = new Error(
        `OpenRouter error: ${res.status} ${res.statusText}${text ? `; body=${text}` : ''}`
      );
      // @ts-expect-error attach http status for mapping
      err.httpStatus = res.status;
      throw err;
    }

    const json = (await res.json()) as OpenRouterChatCompletionResponse;
    const content = json.choices?.[0]?.message?.content ?? '';

    const parsed = extractJsonObject(content);
    const obj =
      typeof parsed === 'object' && parsed !== null
        ? (parsed as Record<string, unknown>)
        : null;

    const rawFront = typeof obj?.front === 'string' ? obj.front : '';
    const rawBack = typeof obj?.back === 'string' ? obj.back : '';

    const front = clampText(rawFront, 200);
    const back = clampText(rawBack, 600);

    if (!front || !back) {
      throw new Error(
        'Nie udało się sparsować odpowiedzi AI do formatu {front, back}.'
      );
    }

    return {
      front,
      back,
      model: json.model ?? args.model,
      promptTokens: json.usage?.prompt_tokens,
      completionTokens: json.usage?.completion_tokens,
      latencyMs: Date.now() - t0,
    };
  } finally {
    clearTimeout(timeout);
  }
}

function stripCodeFences(text: string): string {
  const t = text.trim();
  if (!t.startsWith('```')) return t;
  // Remove first and last fence if present.
  const withoutFirst = t.replace(/^```[a-zA-Z0-9_-]*\s*\n?/, '');
  return withoutFirst.replace(/\n?```$/, '').trim();
}

export async function generateTopicDescriptionViaOpenRouter(args: {
  apiKey: string;
  model: string;
  topic: Pick<Topic, 'name' | 'description'>;
  timeoutMs?: number;
}): Promise<{
  description: string;
  model: string;
  promptTokens?: number;
  completionTokens?: number;
  latencyMs: number;
}> {
  const controller = new AbortController();
  const timeoutMs = args.timeoutMs ?? 20_000;
  const t0 = Date.now();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);

  const variationSeed =
    (
      globalThis.crypto as { randomUUID?: () => string } | undefined
    )?.randomUUID?.() ?? `${Date.now()}-${Math.random().toString(16).slice(2)}`;

  const systemPrompt = [
    'Jesteś asystentem, który tworzy OPIS TEMATU do aplikacji z fiszkami.',
    'Twoim celem jest wygenerowanie tekstu, który użytkownik wklei w pole "Opis tematu", aby poprawić jakość generowania fiszek.',
    'Pisz po polsku. Styl: konkretnie, praktycznie, bez lania wody.',
    'Zwróć WYŁĄCZNIE sam opis (czysty tekst), bez JSON, bez markdown, bez cudzysłowów i bez dodatkowych komentarzy.',
    'Opis ma mieć 2–6 zdań i ewentualnie krótką listę aspektów po dwukropku.',
  ].join('\n');

  const userPrompt = [
    `Nazwa tematu: ${args.topic.name}`,
    `Obecny opis (może być pusty): ${args.topic.description}`,
    '',
    'Wygeneruj propozycję opisu, która: (1) precyzuje zakres, (2) podaje przykładowe wątki/aspekty, (3) mówi jakiego stylu oczekujemy od fiszek.',
    `Seed (nie wypisuj go w odpowiedzi): ${variationSeed}`,
  ].join('\n');

  try {
    const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${args.apiKey}`,
        'Content-Type': 'application/json',
        'Cache-Control': 'no-store',
        Pragma: 'no-cache',
        'X-Request-Id': variationSeed,
      },
      body: JSON.stringify({
        model: args.model,
        temperature: 0.8,
        top_p: 0.95,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
      }),
      cache: 'no-store',
      signal: controller.signal,
    });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      const err = new Error(
        `OpenRouter error: ${res.status} ${res.statusText}${text ? `; body=${text}` : ''}`
      );
      // @ts-expect-error attach http status for mapping
      err.httpStatus = res.status;
      throw err;
    }

    const json = (await res.json()) as OpenRouterChatCompletionResponse;
    const raw = json.choices?.[0]?.message?.content ?? '';
    const cleaned = clampText(
      stripCodeFences(raw).replace(/^["']|["']$/g, ''),
      2000
    );

    if (!cleaned) throw new Error('Nie udało się wygenerować opisu tematu.');

    return {
      description: cleaned,
      model: json.model ?? args.model,
      promptTokens: json.usage?.prompt_tokens,
      completionTokens: json.usage?.completion_tokens,
      latencyMs: Date.now() - t0,
    };
  } finally {
    clearTimeout(timeout);
  }
}
