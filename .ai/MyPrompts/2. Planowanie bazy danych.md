<conversation_summary>
<decisions>
1. Systemowa struktura „Random Collection” + „Random Topic” będzie **tworzona automatycznie per użytkownik** przy rejestracji (dla spójności nawigacji kolekcja → temat → fiszka).
2. Lista domen/tematów do losowania **nie będzie przechowywana w DB**; będzie zaszyta w backendzie i dołączana do requestu przy generowaniu w random temacie.
3. Nazwy kolekcji i tematów mają być **unikalne per użytkownik** (dla tematów w obrębie kolekcji).
4. Opis tematu przechowujemy **tylko jako aktualny stan**, bez historii wersji.
5. Opis tematu będzie przechowywany jako **tekst/HTML z WYSIWYG**; opis może być pusty (temat można utworzyć i uzupełnić później), a UI zablokuje generowanie bez opisu.
6. „Ulubione” to **tylko przełącznik** (boolean) na fiszce.
7. Metryki AI będą oparte o **zdarzenia generacji** (akceptacja/odrzucenie/pominięcie) w osobnej tabeli eventów.
8. Limit dzienny generacji AI: liczymy **tylko udane generacje** (po udanym response), reset o **00:00 UTC**, a implementacja ma być najprostsza (zliczanie eventów).
9. `edited_by_user` ma oznaczać **kiedykolwiek edytowano po utworzeniu** (dla każdej fiszki).
10. `source` fiszki ma być ustawiane na INSERT i **niemodyfikowalne** (manual vs AI).
11. Fiszka **zawsze należy do tematu**, a temat do kolekcji; nie przewidujemy „inbox” bez tematu.
12. Blokujemy zmianę nazw kolekcji/tematów na poziomie DB (trigger) zgodnie z MVP oraz dodatkowo chronimy byty randomowe (blokada DELETE i blokada zmiany `system_key`).
13. Admin to **flaga**; admin ma widzieć **tylko metryki** (bez danych użytkowników).
14. Metryki mają być przygotowane pod przyszłość (czas/dzień, manual vs AI, random vs non-random, model), ale zaczynamy od najprostszych agregatów.
15. Indeksy: startujemy od podstaw (FK + nazwy), a `pg_trgm` pozostaje jako opcjonalny upgrade.
</decisions>

<matched_recommendations>
1. Wprowadzić `system_key` dla rekordów systemowych per user (np. `random_collection`, `random_topic`) i wymusić `unique(user_id, system_key)`; pozwala to mieć te same nazwy u różnych użytkowników i stabilnie identyfikować byty „random”.
2. Dodać tabelę `ai_generation_events` do metryk i limitu: `user_id`, `topic_id`, `status` (accepted/rejected/skipped/failed), `is_random`, `created_at`, oraz `day_utc` (lub wyliczane), plus opcjonalnie `random_domain_label`.
3. Nie przechowywać listy domen w DB; logować ewentualnie `random_domain_label` (i opcjonalnie `random_domain_key`) w eventach dla analityki bez utrzymywania słownika domen w bazie.
4. Opis tematu jako `text` przechowujący HTML/Markdown z WYSIWYG, z sanitizacją/whitelistą tagów po stronie backendu oraz constraintem długości w DB; dopuszczać pusty opis.
5. Blokady integralności: trigger blokujący UPDATE `name` dla `collections/topics`, trigger blokujący UPDATE `source` w `flashcards`, trigger blokujący DELETE dla rekordów z `system_key` random oraz blokada UPDATE `system_key`.
6. Model fiszki: `front` (≤200), `back` (≤600), `source` (enum/check: `manually_created`/`auto_generated`), `is_favorite boolean`, `edited_by_user boolean`.
7. Limit dzienny: najprościej przez zliczanie eventów per `user_id` + `day_utc` (UTC) z indeksem `(user_id, day_utc)`; nie liczyć błędów generowania.
8. RLS: izolacja po `user_id = auth.uid()` dla tabel user-content; admin dostaje wyłącznie widoki/funkcje agregujące metryki bez dostępu do rekordów użytkowników.
9. Indeksy MVP: btree na `(user_id, name)` dla kolekcji/tematów i na FK (`collection_id`, `topic_id`), plus indeksy czasowe dla eventów; `pg_trgm` jako opcjonalne przyspieszenie wyszukiwania `ILIKE` po `front/back`.
10. Metryki admina: przygotować widoki `admin_metrics_summary` oraz `admin_metrics_daily` (po `day_utc`) pod przyszłe wykresy.
</matched_recommendations>

<database_planning_summary>
Główne wymagania schematu:
- Dane są prywatne per użytkownik (Supabase Auth + RLS).
- Hierarchia danych jest stała: **kolekcja → temat → fiszka**.
- Operacje usuwania są **hard delete** (kaskadowo).
- W MVP **nie wolno zmieniać nazw** kolekcji i tematów po utworzeniu.
- AI generuje zawsze 1 propozycję; akceptacja tworzy fiszkę, odrzucenie nie tworzy fiszki, ale wlicza się do accept rate; pominięcie nie wlicza się do accept rate.
- Limit dzienny generacji liczony per user, reset o 00:00 UTC, liczymy **tylko udane generacje**.
- „Random Collection/Random Topic” istnieją **per użytkownik** i są zakładane automatycznie; lista domen losowania jest w backendzie.

Kluczowe encje i relacje (proponowany kształt MVP):
- `profiles` (powiązane z `auth.users`): `id (uuid)`, `is_admin boolean`, timestamps.
- `collections`: `id`, `user_id`, `name`, `system_key nullable`, timestamps.
  - Relacja: `profiles 1—N collections`.
  - Unikalność: `unique(user_id, name)` oraz `unique(user_id, system_key)` (gdy nie-NULL).
- `topics`: `id`, `user_id`, `collection_id`, `name`, `description text`, `system_key nullable`, timestamps.
  - Relacja: `collections 1—N topics`.
  - Unikalność: `unique(user_id, collection_id, name)` oraz `unique(user_id, system_key)` (gdy nie-NULL).
- `flashcards`: `id`, `user_id`, `topic_id`, `front`, `back`, `source`, `is_favorite`, `edited_by_user`, timestamps.
  - Relacja: `topics 1—N flashcards`.
  - Constraints: długości 200/600, `topic_id not null`.
- `ai_generation_events`: `id`, `user_id`, `topic_id`, `status`, `is_random`, `random_domain_label nullable`, `model nullable`, `prompt_tokens nullable`, `completion_tokens nullable`, `latency_ms nullable`, `created_at`, `day_utc (date)`.
  - Służy do: accept rate, rejected count, udział AI, limit dzienny, przyszłe statystyki.
  - Uwaga: ustalono, że **nie zapisujemy `front/back`** na tym etapie.

Bezpieczeństwo (RLS) i zasady dostępu:
- Wszystkie tabele user-content (`collections`, `topics`, `flashcards`, `ai_generation_events`) filtrują `user_id = auth.uid()` dla SELECT/INSERT/UPDATE/DELETE.
- Rekordy randomowe są chronione dodatkowo:
  - Trigger blokujący DELETE dla `system_key in ('random_collection','random_topic')`.
  - Trigger blokujący UPDATE `name` (dla wszystkich) i `system_key` (dla wszystkich).
- Admin:
  - `profiles.is_admin = true`.
  - Admin nie ma SELECT do tabel user-content; dostaje tylko dostęp do widoków/funkcji metryk (agregaty globalne i dzienne).

Skalowalność i wydajność:
- Indeksy MVP:
  - `collections(user_id, name)`, `topics(user_id, collection_id, name)`.
  - FK: `topics(collection_id)`, `flashcards(topic_id)`.
  - Eventy: `ai_generation_events(user_id, day_utc)`, plus opcjonalnie `(day_utc)`, `(is_random, day_utc)`, `(model, day_utc)`.
- Wyszukiwanie strict w MVP: `ILIKE` (bez normalizacji); `pg_trgm` zostaje jako opcjonalny upgrade, gdy wzrośnie liczba fiszek.

Obszary „random”:
- Struktura random jest w DB (per user) tylko jako kolekcja/temat dla spójnej nawigacji.
- Słownik domen losowania jest w backendzie; do DB trafia jedynie `random_domain_label` w eventach (opcjonalnie także model/tokens/latency).
</database_planning_summary>

<unresolved_issues>
1. Maksymalna długość `topics.description` (N) do constraintu DB (wymaga decyzji liczbowej).
2. Dokładna whitelist/tagi i format zapisu opisu (HTML vs Markdown) oraz miejsce sanitizacji (backend) — kierunek jest ustalony, ale parametry nie.
3. Ostateczny zestaw statusów dla `ai_generation_events` (czy oprócz accepted/rejected/skipped ma być też `failed` i jak go raportować w metrykach).
4. Czy `random_domain_label` ma być jedynym polem domeny, czy jednak warto dodać stabilny `random_domain_key` (ustalono, że „spoko” dla obu, ale nie przesądzono, czy oba wdrażamy).
</unresolved_issues>
</conversation_summary>