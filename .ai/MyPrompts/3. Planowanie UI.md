<conversation_summary>
<decisions>
1. Główne sekcje nawigacji w MVP: **Dashboard**, **Kolekcje**, **Ulubione** oraz **Avatar/Dropdown** (User profile, Log out).  
2. Terminologia została ujednolicona: **„kategoria” = „kolekcja”** → używamy tylko „Kolekcja”.  
3. „Kolekcja losowa / Temat losowy” są **widoczne na listach** i mają **badge**, a „Kolekcja losowa” jest **przypięta (pinned) na dole** listy w sidebarze Dashboardu.  
4. Dashboard ma układ: **lewy sidebar** z listą kolekcji oraz **prawa część** z gridem **6 losowych ulubionych**.  
5. Sidebar na Dashboardzie pokazuje **łącznie 6 kolekcji** (w tym element systemowy), bez wyszukiwarki; pod listą jest przycisk **„Wszystkie kolekcje”** przenoszący do strony kolekcji.  
6. Dodawanie kolekcji w sidebarze Dashboardu odbywa się przez **inline input**, z obsługą: Enter/Esc oraz ikonami **CHECK** (dodaj) i **X** (anuluj), widocznymi tylko w trybie dodawania.  
7. Przechodzenie między zasobami ma być oparte o **osobne trasy (routing)**, a nie stan wewnętrzny jednego widoku.  
8. Generowanie AI: podgląd propozycji w **modalu**; po Zapisz/Odrzuć użytkownik **wraca do listy fiszek** i kolejne generowanie uruchamia ręcznie.  
9. Licznik limitu generacji (w UI nazwany jako **pozostałe generacje**) ma być **widoczny zawsze w navbarze** (obok avatara), a gdy wartość nieznana — wyświetlany jako **skeleton/ghost loader**; dodatkowo ma być **tooltip** z informacją o resecie (00:00 UTC).  
10. Źródło avatara: bez pola `name` → avatar wyświetla **pierwszą literę z e-maila**.  
11. Dropdown po kliknięciu avatara ma zawierać **tylko**: „User profile” i „Log out”.  
12. „User profile” to osobna trasa/strona: **e-mail + zmiana hasła** (przez Supabase); jeśli użytkownik jest adminem, na tej samej stronie pojawia się **dodatkowa sekcja statystyk** (bez osobnej trasy „Admin panel”).  
13. Wdrożymy **usuwanie kolekcji** w UI z potwierdzeniem **OK/Anuluj** i ostrzeżeniem o kaskadowym usunięciu (tematy + fiszki).  
14. Po usunięciu kolekcji lub gdy strona zasobu zwróci `404`, UI ma przekierować na **`/collections`** i pokazać toast/komunikat.  
15. Edycja opisu tematu: osobna strona tematu, zapis **manualny** (przycisk „Zapisz”), z czytelnymi stanami saving/saved/error.  
16. Lista fiszek: edycja w **modalu/drawerze**, walidacja limitów 200/600, źródło tylko do odczytu; oznaczanie `edited_by_user` w UI.  
17. Dashboard (6 losowych ulubionych): klik w kartę **nie przenosi na inną stronę**; otwiera **modal szczegółów** z front/back oraz informacjami i linkami do kolekcji/tematu.  
18. Strategia stanu i integracji: wybór **TanStack Query** jako podstawy cache/invalidate/refetch oraz obsługi requestów.  
19. Limit generacji jest **konsumowany od razu po udanej generacji** (zużycie następuje przy `POST /ai/generate`).  
20. Utrzymanie limitu w backendzie: wartość „pozostałe generacje” ma być przechowywana w **`profiles`** i **nadpisywana po udanej generacji**; akceptowane jest ryzyko niespójności w edge-case’ach (równoległe żądania).
</decisions>

<matched_recommendations>
1. Zastosować **oddzielne trasy** dla kluczowych widoków (kolekcje/tematy/fiszki/user), aby uprościć nawigację, odświeżanie i cache.  
2. Wdrożyć **App Shell** z dwoma layoutami: `DashboardLayout` (Navbar +++ sidebar i grid) oraz `AppLayout` (navbar i content) dla spójności i prostoty.  
3. Generowanie AI jako **modal preview** z blokadą akcji podczas requestu oraz obsługą stanów błędów (`429/502`) i jasnymi komunikatami.  
4. Utrzymywać parametry list (szukanie/filtry) w URL tam gdzie mają sens (np. lista fiszek w temacie), a odświeżenia robić przez **invalidate** w TanStack Query.  
5. Standaryzować obsługę błędów API: inline dla walidacji formularzy (`400/409`), toast dla akcji globalnych (delete/save), oraz dedykowane komunikaty w modalach dla AI (`429/502`).  
6. Zapewnić UX dla destrukcyjnych operacji: **modal potwierdzenia** usuwania kolekcji z ostrzeżeniem o kaskadzie.  
7. Wprowadzić konsekwentną strategię bezpieczeństwa w UI: guard sesji, poprawne reakcje na `401`, ukrywanie/warunkowe pokazywanie sekcji admina na podstawie `is_admin`.  
8. Dla dostępności: korzystać z Shadcn/ui (Dialog/Drawer/Input/Button/Toast) i zadbać o focus management, obsługę klawiatury i czytelne komunikaty błędów.  
9. Dla responsywności: mobile-first, modal/drawer dla szczegółów/propozycji, a na desktopie czytelny układ sidebar + content.  
10. Dla licznika limitu: pokazać go stale w navbarze i stosować **skeleton/ghost loader** przy initial load, a potem odświeżać bez “skakania” UI (utrzymywać ostatnią wartość).
</matched_recommendations>

<ui_architecture_planning_summary>
**a) Główne wymagania dotyczące architektury UI**
- MVP ma być oparte o prostą, czytelną nawigację i trasy: Dashboard jako ekran startowy po zalogowaniu, osobna strona kolekcji i dalej hierarchia kolekcja → tematy → fiszki.  
- UI ma zawierać stały **navbar** z awatarem i widocznym stale licznikiem „pozostałe generacje”, z tooltipem resetu o 00:00 UTC.  
- Dashboard ma unikalny układ z sidebarem (mini-lista kolekcji) i sekcją treści (grid ulubionych).

**b) Kluczowe widoki, ekrany i przepływy użytkownika**
- **Dashboard**:
  - Lewy sidebar: 6 kolekcji + pinned „Kolekcja losowa” na dole (badge), inline dodawanie kolekcji (input + X/CHECK), przycisk „Wszystkie kolekcje”.
  - Prawa część: grid 6 losowych ulubionych; klik w kartę otwiera modal szczegółów (front/back + metadane + linki do kolekcji/tematu).
- **Kolekcje (`/collections`)**:
  - Lista kolekcji (pełna), możliwość przejścia do tematów danej kolekcji.
  - Wdrożone **usuwanie kolekcji** z modalem OK/Anuluj i ostrzeżeniem o kaskadzie.
- **Tematy (`/collections/:id/topics`)**:
  - Lista tematów w kolekcji + możliwość tworzenia tematu.
  - Wejście do szczegółów tematu (opis).
- **Temat (`/topics/:id`)**:
  - Edycja opisu tematu z manualnym zapisem i obsługą stanów.
- **Fiszki (`/topics/:id/flashcards`)**:
  - Lista fiszek + filtry/szukaj (zaakceptowane w rozmowie jako kierunek).
  - Edycja fiszki w modalu/drawerze (200/600), oznaczenie `edited_by_user`.
  - Generowanie AI: uruchomienie generacji → modal preview; po akcji wraca do listy, bez auto-generowania kolejnej.
- **User profile (`/user`)**:
  - Zawsze: e-mail + zmiana hasła (Supabase).
  - Dodatkowo dla admina: sekcja statystyk na tej samej stronie (bez osobnej trasy admina).
- **Auth**:
  - Publiczny dostęp do logowania/rejestracji, a trasy aplikacji danych osłonięte guardem sesji.

**c) Strategia integracji z API i zarządzania stanem**
- Warstwa danych oparta o **TanStack Query**: cache, invalidation po mutacjach, refetch przy focusie, spójne stany loading/error.
- Limit generacji:
  - Konsumowany **po udanym `POST /api/v1/ai/generate`**.
  - Wartość „pozostałe generacje” ma być przechowywana w `profiles` i **nadpisywana po generate** (zaakceptowane ryzyko niespójności w edge-case’ach).
  - UI licznika w navbarze: skeleton/ghost loader przy braku danych, tooltip resetu 00:00 UTC.
- Obsługa nawigacji i błędów zasobów:
  - `404` / brak zasobu → przekierowanie na `/collections` z komunikatem.
  - Usunięcie kolekcji wymusza odświeżenie list (invalidate) i porządny redirect, jeśli użytkownik był „w środku” usuniętego zasobu.

**d) Responsywność, dostępność i bezpieczeństwo**
- Responsywność: mobile-first; modale/drawery dla szczegółów i AI preview; Dashboard z sidebarem na desktopie, a na mobile zapewnić sensowną nawigację (np. wysuwany panel lub sekcja nad treścią).
- Dostępność: Shadcn/ui + poprawne focus management (Dialog/Drawer), obsługa klawiatury (Enter/Esc), czytelne komunikaty błędów i stany disabled/loading.
- Bezpieczeństwo: UI respektuje auth (guard), reaguje na `401` (wylogowanie/przekierowanie), a sekcja admina jest warunkowa (na podstawie `profiles.is_admin`).

**e) Obszary wymagające dalszego doprecyzowania (przed implementacją)**
- Doprecyzowanie kontraktu backendowego dla licznika limitu w `profiles` (nazwa pól, typy, `reset_at_utc`) oraz częstotliwość odświeżania w UI (bez pollingu vs lekki refetch).
- Szczegóły sortowania i doboru „6 kolekcji” do sidebaru (finalnie: `updated_at` desc) oraz czy „Kolekcja losowa” ma być liczona do tej szóstki czy zawsze dodatkowa.
- Payload dla „losowych ulubionych” pod modal szczegółów: czy API ma zwracać też `collection_id`/nazwy, czy UI wykona dodatkowy lookup (i jak to cachujemy).
</ui_architecture_planning_summary>

<unresolved_issues>
1. Dokładny model danych/licznika limitu w `profiles`: nazwy pól, format `reset_at_utc`, oraz czy licznik aktualizujemy wyłącznie po generate czy także po accept/reject/skip (obecnie decyzja: zużycie na generate, ale refresh/invalidate w UI trzeba jeszcze sfinalizować).  
2. Czy „Kolekcja losowa” w sidebarze liczy się do 6 pozycji, czy jest zawsze dodatkowym elementem pinned (w rozmowie jest pinned na dole, ale warto doprecyzować „limit 6” względem elementu systemowego).  
3. Jak dokładnie UI ma pozyskiwać dane kolekcji/tematu do modala z ulubionych na Dashboardzie: rozszerzenie endpointu random favorites vs dodatkowe zapytania po `topic_id` (wymaga decyzji pod kątem wydajności i prostoty).
</unresolved_issues>
</conversation_summary>